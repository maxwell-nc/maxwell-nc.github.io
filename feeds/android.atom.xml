<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Maxwell's Growth Path - android</title><link href="https://maxwell-nc.github.io/" rel="alternate"></link><link href="https://maxwell-nc.github.io/feeds/android.atom.xml" rel="self"></link><id>https://maxwell-nc.github.io/</id><updated>2017-06-02T00:00:00+08:00</updated><entry><title>Android中的Lambda表达式详解</title><link href="https://maxwell-nc.github.io/android/retrolambda.html" rel="alternate"></link><published>2017-06-02T00:00:00+08:00</published><updated>2017-06-02T00:00:00+08:00</updated><author><name>Maxwell-nc</name></author><id>tag:maxwell-nc.github.io,2017-06-02:/android/retrolambda.html</id><summary type="html">&lt;h2&gt;前序&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;Lambda表达式是一个&lt;strong&gt;看上去&lt;/strong&gt;很难懂的语法糖，目前有一种趋势表明它越来越火，各种语言都开始支持Lambda表达式。即使你不使用这种语法糖，你也应该去学习了解，否则你可能看不懂很多代码。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;不过由于Java8才引入Lambda表达式，而Android Studio一直都是嵌入JDK(Java Development Kit)1.7，自然要在Android Studio上使用Lamda表达式，这时候只能靠开源力量，自然就有Retrolambda这个Gradle插件。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;当然Lambda的好处、缺点这里就不解析了，当然我认为无论你是否使用，Lambda也是需要学习的一个语法糖。本文为了方便阅读，尽可能避免会涉及到其他Java8的新特性。&lt;/p&gt;
&lt;h2&gt;引入Retrolambda&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;首先需要使用Lambda，你要有一个JDK(Java Development Kit)1.8，修改你的项目JDK版本为1.8及以上的版本，如下图所示：
&lt;img alt="jdk" src="../images/retrolambda/1.jpg"&gt;
&amp;emsp;&amp;emsp;接下来需要在Application的build.gradle中添加Retrolambda插件(来自mavenCentral依赖库)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;buildscript {

    repositories {
        mavenCentral()
        //...
    }
    dependencies {
        classpath &amp;#39;me.tatarka:gradle-retrolambda:3 …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h2&gt;前序&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;Lambda表达式是一个&lt;strong&gt;看上去&lt;/strong&gt;很难懂的语法糖，目前有一种趋势表明它越来越火，各种语言都开始支持Lambda表达式。即使你不使用这种语法糖，你也应该去学习了解，否则你可能看不懂很多代码。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;不过由于Java8才引入Lambda表达式，而Android Studio一直都是嵌入JDK(Java Development Kit)1.7，自然要在Android Studio上使用Lamda表达式，这时候只能靠开源力量，自然就有Retrolambda这个Gradle插件。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;当然Lambda的好处、缺点这里就不解析了，当然我认为无论你是否使用，Lambda也是需要学习的一个语法糖。本文为了方便阅读，尽可能避免会涉及到其他Java8的新特性。&lt;/p&gt;
&lt;h2&gt;引入Retrolambda&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;首先需要使用Lambda，你要有一个JDK(Java Development Kit)1.8，修改你的项目JDK版本为1.8及以上的版本，如下图所示：
&lt;img alt="jdk" src="../images/retrolambda/1.jpg"&gt;
&amp;emsp;&amp;emsp;接下来需要在Application的build.gradle中添加Retrolambda插件(来自mavenCentral依赖库)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;buildscript {

    repositories {
        mavenCentral()
        //...
    }
    dependencies {
        classpath &amp;#39;me.tatarka:gradle-retrolambda:3.6.1&amp;#39;
        //...
    }
}

allprojects {
    repositories {
        mavenCentral()
        //...
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;然后在需要用用到lambda的模块，比如app模块中的build.gradle文件中设置插件和编译Java版本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//...
apply plugin: &amp;#39;me.tatarka.retrolambda&amp;#39;

android {
    //...
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;如果你的项目使用了混淆，可以添加：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;-dontwarn java.lang.invoke.*
-dontwarn **$$Lambda$*
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;完成了上述操作后执行Gradle Sync然后尝试运行App无误后就代表环境搭建完成。&lt;/p&gt;
&lt;h2&gt;Hello Lambda（IDE自动转换）&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;由于我们现在不懂Lambda表达，所以我们让Android Studio给我们转换出Lambda表达式。假设我们写了一个点击监听器代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//匿名内部类写法&lt;/span&gt;
&lt;span class="n"&gt;findViewById&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;id&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;btn_click&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;setOnClickListener&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;View&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;OnClickListener&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="nd"&gt;@Override&lt;/span&gt;
        &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;onClick&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;View&lt;/span&gt; &lt;span class="n"&gt;view&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;Log&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;i&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tag&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello lambda&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;会发现插件提示可以转换成Lambda表达式，使用自动完成提示快捷键，选择“Replace with lambda”自动转成Lambda表达式：
&lt;img alt="hint" src="../images/retrolambda/2.jpg"&gt;
&amp;emsp;&amp;emsp;最后变成如下的写法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//转成lambda表达式写法&lt;/span&gt;
&lt;span class="n"&gt;findViewById&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;id&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;btn_click&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setOnClickListener&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;view&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Log&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;i&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tag&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello lambda&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;看上去代码精简了不少，下面我们来学习下Lambda表达式的语法。&lt;/p&gt;
&lt;h2&gt;基本形式&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;Lambda表达式无论怎么变化，都有一个基本的形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(参数) -&amp;gt; {表达式}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;其中符号&lt;code&gt;-&amp;gt;&lt;/code&gt;是不变的，&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;参数的变化情况&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无参数&lt;ul&gt;
&lt;li&gt;&lt;code&gt;() -&amp;gt; exp&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;单一参数&lt;ul&gt;
&lt;li&gt;&lt;code&gt;param -&amp;gt; exp&lt;/code&gt;（自动推导参数类型，可省略()括号）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;非单一参数&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(param1,param2) -&amp;gt; exp&lt;/code&gt;（自动推导参数类型）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(int param1,int param2) -&amp;gt; exp&lt;/code&gt;（不能自动推导参数类型）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;表达式的变化情况&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空表达式&lt;ul&gt;
&lt;li&gt;&lt;code&gt;param -&amp;gt; {}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;单行表达式&lt;ul&gt;
&lt;li&gt;&lt;code&gt;param -&amp;gt; exp&lt;/code&gt;（可忽略{}括号，返回表达式也可以省略return）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;非单行表达式&lt;ul&gt;
&lt;li&gt;&lt;code&gt;param -&amp;gt; {exp1;exp2;}&lt;/code&gt;(表达式可以是return语句)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;上述的表达方法可能有些抽象，下面我们来举个例子说明下。
就拿前面我们转换出来的Lambda表达式为例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;view&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Log&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;i&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tag&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello lambda&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;这里的&lt;code&gt;view&lt;/code&gt;属于参数，&lt;code&gt;Log.i("tag","hello lambda")&lt;/code&gt;属于表达式，其中参数属于单一参数，表达式属于单行表达式，所以省略了()和{}这两个括号。&lt;/p&gt;
&lt;h2&gt;为什么&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;我们探讨一下为什么可以这样写，首先这个方法setOnClickListener接收的匿名内部了已经是固定View.OnClickListener类型，而这个接口也只有onClick一个方法，而注解@Override本身也可以忽略的，也就是说这些都是可以忽略推导出来的，自然就可以写成&lt;code&gt;(参数) -&amp;gt; {表达式}&lt;/code&gt;的形式了。也许细心的朋友会问：返回值呢？这我就反问还记得Java的方法签名吗？Java的方法签名中，返回值是无关变量，也就是返回值可以通过方法名和参数列表来确定，这也是为什么重载时不能单一改变方法返回值的原因。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;下面我们看一个带泛型的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ArrayList&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;gt;();&lt;/span&gt;

&lt;span class="c1"&gt;//匿名内部类形式&lt;/span&gt;
&lt;span class="n"&gt;Collections&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sort&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Comparator&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
       &lt;span class="nd"&gt;@Override&lt;/span&gt;
       &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;compare&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Integer&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
           &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
       &lt;span class="o"&gt;}&lt;/span&gt;
   &lt;span class="o"&gt;});&lt;/span&gt;

&lt;span class="c1"&gt;//Lambda写法&lt;/span&gt;
&lt;span class="n"&gt;Collections&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sort&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;上面的Collections.sort方法泛型&lt;T&gt;是可以根据list的泛型进行推导的，自然lambda表达式就无需泛型声明，而对于单一return表达式&lt;code&gt;{return a-b;}&lt;/code&gt;也是可以省略掉return、分号和括号的。关于Comparator接口，大家会发现他不只有一个方法，但是仅仅只有compare方法是必须实现的，也就是当这个匿名内部类只有一个方法的时候，必然是compare方法，当有两个方法的时候也不能使用lambda表达式了。&lt;/p&gt;
&lt;h2&gt;Functional Interface（函数式接口）&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;上面说到Comparator接口只有一个抽象方法需要实现，这样的接口在Java 8中称为函数式接口。在Java 8之后的源码中，这样的接口都会使用&lt;code&gt;@FunctionalInterface&lt;/code&gt;这个注解去标注。可以查看这个注解的注释，其中写到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Conceptually, a functional interface has exactly one abstract method. Since {@linkplain java.lang.reflect.Method#isDefault() default methods} have an implementation, they are not abstract.  If an interface declares an abstract method overriding one of the public methods of {@code java.lang.Object}, that also does &lt;em&gt;not&lt;/em&gt; count toward the interface's abstract method count since any implementation of the interface will have an implementation from {@code java.lang.Object} or elsewhere.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;简单说明一下就是指函数式接口只能有一个抽象方法是不包括default标记的方法（有默认实现）和Object中已有的方法。所以回去看看Comparator接口的源码，它既包含&lt;code&gt;boolean equals(Object obj);&lt;/code&gt;这种Object中已有的方法，也包含default标记的方法。但是只有compare这样一个抽象方法是必须实现的。&lt;/p&gt;
&lt;h2&gt;返回值&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;Lambda表达式除了可以作为参数，也可以作为变量赋值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;OnClickListener&lt;/span&gt; &lt;span class="n"&gt;listener&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Log&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;i&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tag&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;msg&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;btnClick&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setOnClickListener&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;listener&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;Lambda表达式的返回值&lt;strong&gt;不一定是&lt;/strong&gt;函数式接口。&lt;/p&gt;
&lt;h2&gt;变量作用域&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;下面我们来研究lambda表达式中变量作用域，比如说访问外部的类型：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;btnClick&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setOnClickListener&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Log&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;i&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tag&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;valueOf&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;)));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;由于Java8的新特性Effectively final，所以lambda表达式&lt;strong&gt;可以直接访问外部变量而不需要加final，但这个变量不能够修改&lt;/strong&gt;，否则IDE报错。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;另外lambda表达式中的&lt;strong&gt;()中的参数名不能与外部变量同名&lt;/strong&gt;，否则IDE报错。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;对于lambda表达式的&lt;strong&gt;this是代表对应的外部类&lt;/strong&gt;，而不代表匿名内部类本身（这和匿名内部类是不一样的），举个例子说明下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MainActivity&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;AppCompatActivity&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;onCreate&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="n"&gt;savedInstanceState&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//...&lt;/span&gt;
        &lt;span class="n"&gt;btnClick&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setOnClickListener&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;Log&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;i&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tag&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;toString&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;&lt;span class="c1"&gt;//这里的this代表MainActivity&lt;/span&gt;
        &lt;span class="o"&gt;});&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;使用lambda表达式的时候千万要注意变量的作用域。&lt;/p&gt;
&lt;h2&gt;Method References(方法引用)&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;下面我们学习一种lambda表达式简化形式，先举个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ArrayList&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;gt;();&lt;/span&gt;

&lt;span class="c1"&gt;//Lambda基本表达式&lt;/span&gt;
&lt;span class="n"&gt;Collections&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sort&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;compareTo&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;

&lt;span class="c1"&gt;//方法引用&lt;/span&gt;
&lt;span class="n"&gt;Collections&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sort&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;compareTo&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;方法引用的基本形式就是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;类名::方法名
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;方法的()没什么意义，所以不需要写，而对于这个形式可能出现的情况包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;对象::实例方法&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;类::静态方法&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;类型对象::实例方法&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;比如说上面的&lt;code&gt;Integer::compareTo&lt;/code&gt;就属于&lt;code&gt;类型对象::实例方法&lt;/code&gt;这种。再举个例子，比如说&lt;code&gt;System.out::println&lt;/code&gt;这种就是属于&lt;code&gt;类::静态方法&lt;/code&gt;的形式。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;怎么推导？我们从简化过程来一步步说明。就以上面&lt;code&gt;(a, b) -&amp;gt; a.compareTo(b)&lt;/code&gt;这个例子:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;compareTo&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;    &lt;span class="c1"&gt;//原始lambda表达式&lt;/span&gt;
    &lt;span class="c1"&gt;//↓↓↓&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;compareTo&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;//compareTo属于Integer类型对象的方法&lt;/span&gt;
    &lt;span class="c1"&gt;//↓↓↓&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;compareTo&lt;/span&gt;     &lt;span class="c1"&gt;//a、b有顺序，&amp;quot;(b)&amp;quot;可以省略&lt;/span&gt;
    &lt;span class="c1"&gt;//↓↓↓&lt;/span&gt;
&lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;compareTo&lt;/span&gt;   &lt;span class="c1"&gt;//没有使用参数副号，&amp;quot;(a, b) -&amp;gt; &amp;quot;都可以省略&lt;/span&gt;
    &lt;span class="c1"&gt;//↓↓↓&lt;/span&gt;
&lt;span class="nl"&gt;Integer:&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;compareTo&lt;/span&gt;  &lt;span class="c1"&gt;//为了区分，使用::符号&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;另外，如果lambda表达式可以转换成方法引用，Android Studio也是会提示的。&lt;strong&gt;一般只用到一个已存在的方法并且没有额外的参数就可以使用方法引用来表示lambda表达式。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;Constructor References（构造方法引用）&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;下面介绍构造方法引用，实际上有人也把它归为方法引用，因为他的形式是一样的，只是::符号后面跟的方法名变成固定的new，即：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;类名::new
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;这个举例子通常用到新的API，为了防止陌生面孔出现，我们这里通过自定义例子来说明，首先要定义函数式接口，因为方法引用的参数肯定是函数式接口：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@FunctionalInterface&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;Wrapper&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="c1"&gt;//对应Java8中提供的Supplier&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;然后写一个打印字符串是否为空的方法（仅仅为了说明，简单化例子）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;printIsEmpty&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Wrapper&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;wrapper&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Log&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;i&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tag&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wrapper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;isEmpty&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;yes&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;no&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;然后调用方法写法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//匿名内部类&lt;/span&gt;
&lt;span class="n"&gt;printIsEmpty&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Wrapper&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="nd"&gt;@Override&lt;/span&gt;
        &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;});&lt;/span&gt;

&lt;span class="c1"&gt;//lambda表达式原始写法&lt;/span&gt;
&lt;span class="n"&gt;printIsEmpty&lt;/span&gt;&lt;span class="o"&gt;(()&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;

&lt;span class="c1"&gt;//构造方法引用写法&lt;/span&gt;
&lt;span class="n"&gt;printIsEmpty&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;注意的是，还有一种构造方法引用是数组型的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;类名[]::new
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;比如说&lt;code&gt;String[]::new&lt;/code&gt;，这里就不举详细的例子了。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;以上就是Android中使用Lambda表达式的内容，目前由于版本问题，尚未得到普及，不过例如RxJava等一些框架的文章大部分是使用Lambda表达式的形式说明，所以建议还是需要认真学一学，至少能读懂别人写的吧，至于使用不使用那又是另一回事。&lt;/p&gt;</content><category term="android"></category><category term="java8"></category><category term="lambda"></category><category term="retrolambda"></category></entry><entry><title>Android单元测试之AssertJ框架</title><link href="https://maxwell-nc.github.io/android/assertjTest.html" rel="alternate"></link><published>2017-06-01T00:00:00+08:00</published><updated>2017-06-01T00:00:00+08:00</updated><author><name>Maxwell-nc</name></author><id>tag:maxwell-nc.github.io,2017-06-01:/android/assertjTest.html</id><summary type="html">&lt;h2&gt;前序&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;a href="https://maxwell-nc.github.io/android/robolectricTest.html"&gt;上一篇Android单元测试文章&lt;/a&gt;说到如果使用Junit给我们提供的Assert去对比Intent，那就需要每个成员都对比一次，十分不方便，今天给大家带来一个十分便利的框架AssertJ，由于这个框架本身是给Java使用的，我们可以直接使用针对Android设计的&lt;a href="https://github.com/square/assertj-android"&gt;AssertJ-Android框架&lt;/a&gt;。这个框架官方说明中写道“... aims to make it even easier to test Android”（致力于让安卓测试更简单），它和Assertj原版的比较可以看看官方的说明，这个不是本文的重点，这里就不多说了。&lt;/p&gt;
&lt;h2&gt;Gradle依赖&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;首先当然是引入AssertJ-Android，直接在app的build.gradle中添加：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;testCompile &amp;#39;com.squareup.assertj:assertj-android:1.1.1&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;如果遇到冲突问题，比如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Conflict with dependency 'com.android.support:support-annotations' in project ':app'. Resolved versions for …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;h2&gt;前序&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;a href="https://maxwell-nc.github.io/android/robolectricTest.html"&gt;上一篇Android单元测试文章&lt;/a&gt;说到如果使用Junit给我们提供的Assert去对比Intent，那就需要每个成员都对比一次，十分不方便，今天给大家带来一个十分便利的框架AssertJ，由于这个框架本身是给Java使用的，我们可以直接使用针对Android设计的&lt;a href="https://github.com/square/assertj-android"&gt;AssertJ-Android框架&lt;/a&gt;。这个框架官方说明中写道“... aims to make it even easier to test Android”（致力于让安卓测试更简单），它和Assertj原版的比较可以看看官方的说明，这个不是本文的重点，这里就不多说了。&lt;/p&gt;
&lt;h2&gt;Gradle依赖&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;首先当然是引入AssertJ-Android，直接在app的build.gradle中添加：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;testCompile &amp;#39;com.squareup.assertj:assertj-android:1.1.1&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;如果遇到冲突问题，比如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Conflict with dependency 'com.android.support:support-annotations' in project ':app'. Resolved versions for app (23.0.1) and test app (22.2.1) differ. See http://g.co/androidstudio/app-test-app-conflict for details.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;可以排除部分模块,如上述的support-annotations：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;testCompile( &amp;#39;com.squareup.assertj:assertj-android:1.1.1&amp;#39; ,{
    exclude group: &amp;#39;com.android.support&amp;#39;, module: &amp;#39;support-annotations&amp;#39;
})
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;值得注意，Support-v4和Appcompat也是需要单独的依赖：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;testCompile &amp;#39;com.squareup.assertj:assertj-android-support-v4:1.1.1&amp;#39;
testCompile &amp;#39;com.squareup.assertj:assertj-android-appcompat-v7:1.1.1&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;AssertJ-Android还支持很多其他库，这些依赖都可以在官方文档找到，这里不一一说明。&lt;/p&gt;
&lt;h2&gt;快速入门&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;由于AssertJ比较简单，这里就直接给一个简单例子说明下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Assertions&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;assertThat&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;actual&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;isEqualTo&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expected&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;上面的是比较两个对象的断言，&lt;strong&gt;注意assertThat传入的是actual实际对象&lt;/strong&gt;，这个容易和Junit的搞混。&lt;/p&gt;
&lt;h2&gt;导包问题&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;注意AssertJ-Android包含了AssertJ和扩展的Android API,分别对应:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;org&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;assertj&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;core&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;api&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;Assertions&lt;/span&gt;
&lt;span class="n"&gt;org&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;assertj&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;android&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;api&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;Assertions&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;使用的时候要注意包名，否则可能会找不到方法。&lt;/p&gt;
&lt;h2&gt;链式判断&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;前文说到，使用Junit的Assert判断两个Intent比较麻烦，下面我们以Intent为例子说明链式判断：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Assertions&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;assertThat&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;actual&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
          &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;hasComponent&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expected&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getComponent&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt;
          &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;hasAction&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expected&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getAction&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt;
          &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;hasFlags&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expected&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getFlags&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;首先Assertions.assertThat会根据actual的类型返回对应的AbstractAssert子类，比如这里返回的是IntentAssert，而IntentAssert里面每个方法都是返回IntentAssert，这样可以做到链式调用，快速判断两个对象的属性。而且针对不同的对象他给出的方法也不一样，比如说MapAssert它身上有contains等方法专门针对Map对象来判断，十分方便。这里就不一样介绍了，使用IDE的自动提示功能很快你就能找到需要的方法了。&lt;/p&gt;
&lt;h2&gt;自定义Assertions&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;实际上AssertJ-Android就是基于AssertJ基础上添加了大量Android相关API的自定义Assertions。下面我们也来为我们自己写的类自定义Assertions。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;首先假设我们有一个UserInfo类需要我们自定义Assert类：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;UserInfo&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;userName&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;//here is getter and setter...&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;然后我们定义一个UserInfoAssert类，前面说过，这些Assert类都是继承自AbstractAssert类，注意泛型即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;UserInfoAssert&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;AbstractAssert&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;UserInfoAssert&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UserInfo&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;UserInfoAssert&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UserInfo&lt;/span&gt; &lt;span class="n"&gt;actual&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;actual&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UserInfoAssert&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;UserInfoAssert&lt;/span&gt; &lt;span class="nf"&gt;hasUserName&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;isNotNull&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;&lt;span class="c1"&gt;//防止actual为空&lt;/span&gt;
        &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;userName&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;actual&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getUserName&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TextUtils&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;isEmpty&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;userName&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;failWithMessage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Expected username was not null but was null.&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;最后需要自定义一个Assertions类给我们提供访问UserInfoAssert：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Assertions&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="n"&gt;UserInfoAssert&lt;/span&gt; &lt;span class="nf"&gt;assertThat&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UserInfo&lt;/span&gt; &lt;span class="n"&gt;actual&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;UserInfoAssert&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;actual&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;完了之后就可以使用类似AssertJ的写法了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Assertions&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;assertThat&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;UserInfo&lt;/span&gt;&lt;span class="o"&gt;()).&lt;/span&gt;&lt;span class="na"&gt;hasUserName&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;上述代码如无意外就会抛出一个错误，需要注意的只是Assertions的导包问题。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;经过一系列单元测试框架介绍，Android单元测试的基本内容就这些了，比如说如果快速编写单元测试用例等等这些，如果需要深入了解的话可以去看看一些相关的书籍。&lt;/p&gt;
&lt;h2&gt;相关文章&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Android单元测试之JUnit框架：&lt;/strong&gt;&lt;a href="https://maxwell-nc.github.io/android/junitTest.html"&gt;https://maxwell-nc.github.io/android/junitTest.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Android单元测试之Mockito框架：&lt;/strong&gt;&lt;a href="https://maxwell-nc.github.io/android/mockitoTest.html"&gt;https://maxwell-nc.github.io/android/mockitoTest.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Android单元测试之Robolectric框架：&lt;/strong&gt;&lt;a href="https://maxwell-nc.github.io/android/robolectricTest.html"&gt;https://maxwell-nc.github.io/android/robolectricTest.html&lt;/a&gt;&lt;/p&gt;</content><category term="android"></category><category term="test"></category><category term="assertj"></category></entry><entry><title>Android单元测试之Robolectric框架</title><link href="https://maxwell-nc.github.io/android/robolectricTest.html" rel="alternate"></link><published>2017-05-26T00:00:00+08:00</published><updated>2017-05-26T00:00:00+08:00</updated><author><name>Maxwell-nc</name></author><id>tag:maxwell-nc.github.io,2017-05-26:/android/robolectricTest.html</id><summary type="html">&lt;h2&gt;前序&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;a href="https://maxwell-nc.github.io/android/mockitoTest.html"&gt;上一篇Android单元测试文章&lt;/a&gt;最后说道要测试Android代码逻辑，光有JUnit和Mockito是不够的，假设你使用了TextView的setText,用Mockito框架的话，默认的TextView的getText方法会返回null,如果是简单的代码，使用Mockito的桩设置还可以接受，如果是要测试到Activity的生命周期等一些复杂逻辑就显得比较复杂了。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;为了解决这个问题,诞生了Instrumentation、Robolectric等等的测试框架，不过Instrumentation实际上还是要运行代码到平台上测试，耗费大量的时间，我们今天要介绍的是运行在JVM上的Robolectric测试框架。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;PS：本来想找一些参考文章，结果发现网上的文章多半是说一半没有另一半，或者有些可能遇到的问题没有指出。最主要的是官方的文档也是少的可怜，给出的Sample也是旧版本的，完全很多地方都不一样了。&lt;/p&gt;
&lt;h2&gt;Robolectric基本原理&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;在使用Robolectric之前我们先要明白Robolectric是如何工作的。比如说我们前文说到的TextView，如果我们使用Mockito，他给我们提供的是Mock后的TextView，而Robolectric给我们提供的是ShadowTextView，这个ShadowTextView实现了TextView身上的方法，但他又与Android的运行环境无关，也就是说他可以像使用TextView一样的方法，但不用在平台上运行代码，大大提高测试效率。&lt;/p&gt;
&lt;h2&gt;特别注意事项&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;使用Robolectric要注意它的版本以及其支持的SDK版本，如果不支持千万不要用高版本SDK编译，或者升级Gradle插件和编译器版本，否则运行时会出现各种问题。如果版本太高，例如我尝试使用Gradle Wrapper版本4.0配合Gradle插件3.0.0版本时发现是无法成功测试的。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;本文采用最新的Robolectric 3.x（目前是3.4-rc2 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;前序&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;a href="https://maxwell-nc.github.io/android/mockitoTest.html"&gt;上一篇Android单元测试文章&lt;/a&gt;最后说道要测试Android代码逻辑，光有JUnit和Mockito是不够的，假设你使用了TextView的setText,用Mockito框架的话，默认的TextView的getText方法会返回null,如果是简单的代码，使用Mockito的桩设置还可以接受，如果是要测试到Activity的生命周期等一些复杂逻辑就显得比较复杂了。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;为了解决这个问题,诞生了Instrumentation、Robolectric等等的测试框架，不过Instrumentation实际上还是要运行代码到平台上测试，耗费大量的时间，我们今天要介绍的是运行在JVM上的Robolectric测试框架。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;PS：本来想找一些参考文章，结果发现网上的文章多半是说一半没有另一半，或者有些可能遇到的问题没有指出。最主要的是官方的文档也是少的可怜，给出的Sample也是旧版本的，完全很多地方都不一样了。&lt;/p&gt;
&lt;h2&gt;Robolectric基本原理&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;在使用Robolectric之前我们先要明白Robolectric是如何工作的。比如说我们前文说到的TextView，如果我们使用Mockito，他给我们提供的是Mock后的TextView，而Robolectric给我们提供的是ShadowTextView，这个ShadowTextView实现了TextView身上的方法，但他又与Android的运行环境无关，也就是说他可以像使用TextView一样的方法，但不用在平台上运行代码，大大提高测试效率。&lt;/p&gt;
&lt;h2&gt;特别注意事项&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;使用Robolectric要注意它的版本以及其支持的SDK版本，如果不支持千万不要用高版本SDK编译，或者升级Gradle插件和编译器版本，否则运行时会出现各种问题。如果版本太高，例如我尝试使用Gradle Wrapper版本4.0配合Gradle插件3.0.0版本时发现是无法成功测试的。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;本文采用最新的Robolectric 3.x（目前是3.4-rc2），测试的SDK API版本为25，Gradle Wrapper为3.3，Gradle插件为2.3.0。另外我用的Android Studio版本也是3.0版本，如果低于2.0的版本的建议升级，否则可能会遇到其他问题（本文就不在讨论了）。&lt;/p&gt;
&lt;h2&gt;集成Robolectric&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;首先第一步是添加Gradle编译依赖，由于Robolectric本身比较大，所以对于一些功能，它采用add-on的方式，除了核心包其他都是可选添加的，编辑app下的build.gradle文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;dependencies {
    testCompile &amp;#39;org.robolectric:robolectric:3.+&amp;#39; //核心包
    testCompile &amp;#39;org.robolectric:shadows-support-v4:3.+&amp;#39; //支持Support-v4包
    testCompile &amp;quot;org.robolectric:shadows-multidex:3.+&amp;quot; //支持Multidex功能
    //...
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;值得注意的是，要使用Robolectric也要添加JUnit依赖，具体可以回顾一下&lt;a href="https://maxwell-nc.github.io/android/junitTest.html"&gt;《Android单元测试之JUnit框架》&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;测试运行环境（@RunWith）&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;还记之前文章说到的JUnit给我们提供一个&lt;code&gt;@RunWith&lt;/code&gt;注解去设置测试运行环境吗？Robolectric提供一个&lt;code&gt;RobolectricTestRunner&lt;/code&gt;的沙盒测试运行环境，注意低版本的Robolectric可能不是这个类名。这个测试环境使用各种Shadow类代替真正的Android对象，从而实现模拟Android App的运行。所以所有需要使用Robolectric的测试类都要加上类注解：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@RunWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;RobolectricTestRunner&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ExampleUtilsTest&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Robolectric配置（@Config）&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;很多网上的教程都是直接给了一个简单的例子，结果自己运行的时候会发现出现各种问题，所以这里先不给例子，先说一下怎么配置才能正确地运行。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;为了方便配置RobolectricTestRunner提供的环境，比如要设置运行的SDK版本，设置包名，自定义Application等等配置，Robolectric提供了一个&lt;code&gt;@Config&lt;/code&gt;注解方便用户配置Robolectric。我们可以从源码中看到@Config可以接受很多参数，下面是几个比较常用的:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;sdk：&lt;/strong&gt;SDK版本&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;manifest：&lt;/strong&gt;清单文件位置&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;buildDir：&lt;/strong&gt;构建目录&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;packageName：&lt;/strong&gt;包名&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;constants：&lt;/strong&gt;常量设置（一般直接使用BuildConfig）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;shadows：&lt;/strong&gt;自定义Shadow类&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;application：&lt;/strong&gt;自定义Application类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;由于有很多参数，Robolectric为了使用方便提供了很多默认值，通常唯一必须指定的只有constants，因为配置BuildConfig后Robolectric框架会自动完成寻找各种目录和配置包名等等操作。所以需要在使用Robolectric的测试类上加上@Config注解：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@RunWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;RobolectricTestRunner&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="nd"&gt;@Config&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;constants&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BuildConfig&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ExampleUtilsTest&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;好了，按照之前说的，配置BuildConfig后就会自动完成寻找各种目录和配置包名等等操作，唯独这个AndroidManifest清单文件可能会寻找不到。&lt;/p&gt;
&lt;h2&gt;AndroidManifest问题&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;如果你按照其他的教程来操作，很可能运行时就提示:&lt;code&gt;No such manifest file: build\intermediates\bundles\debug\AndroidManifest.xml&lt;/code&gt;，无法找到AndroidManifest.xml。我们来分析分析这个问题。首先由于@Config最终是给RobolectricTestRunner使用的，所以我们打开RobolectricTestRunner的源码，可以找到：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;FrameworkMethod&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nf"&gt;getChildren&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//...&lt;/span&gt;
    &lt;span class="n"&gt;Config&lt;/span&gt; &lt;span class="n"&gt;config&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getConfig&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;frameworkMethod&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getMethod&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
    &lt;span class="n"&gt;AndroidManifest&lt;/span&gt; &lt;span class="n"&gt;appManifest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getAppManifest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;当然我们找到getAppManifest方法发现它采用了ManifestFactory工厂去生产清单文件，找到工厂接口实现类GradleManifestFactory是适合于Android的清单工厂。可以看到里面各种自动寻找目录的逻辑，其中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;manifestName&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;manifest&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;URL&lt;/span&gt; &lt;span class="n"&gt;manifestUrl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getClass&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getClassLoader&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getResource&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;manifestName&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;manifestUrl&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;manifestUrl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getProtocol&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;file&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;manifest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FileFsFile&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;from&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;manifestUrl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getPath&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FileFsFile&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;from&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buildOutputDir&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;manifests&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;full&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;exists&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;manifest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FileFsFile&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;from&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buildOutputDir&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;manifests&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;full&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;flavor&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;abiSplit&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;manifestName&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FileFsFile&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;from&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buildOutputDir&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;manifests&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;aapt&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;exists&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// Android gradle plugin 2.2.0+ can put library manifest files inside of &amp;quot;aapt&amp;quot; instead of &amp;quot;full&amp;quot;&lt;/span&gt;
  &lt;span class="n"&gt;manifest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FileFsFile&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;from&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buildOutputDir&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;manifests&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;aapt&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;flavor&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;abiSplit&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;manifestName&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;manifest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FileFsFile&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;from&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buildOutputDir&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;bundles&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;flavor&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;abiSplit&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;manifestName&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;这部分代码就是寻找清单文件的代码，为了偷懒，直接下断点，看看生成的路径是否正确：
&lt;img alt="path" src="../images/robolectricTest/1.jpg"&gt;
&amp;emsp;&amp;emsp;可以看到获取完整路径后实际上是少了一个模块名称，所以会走到最后的逻辑，从而导致提示报错。比较麻烦的时候，这个工厂我们不能自定义，退而求之我们修改他的前序buildOutputDir参数，这个参数就是对应Config参数buildDir,所以给Config增加一个参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@RunWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;RobolectricTestRunner&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="nd"&gt;@Config&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;constants&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BuildConfig&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;buildDir&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;app/build&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ExampleUtilsTest&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;注意相对和绝对路径问题。&lt;/p&gt;
&lt;h2&gt;Robolectric运行测试&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;下面我们尝试些一个测试例子，创建一个Activity并且验证它非null：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@RunWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;RobolectricTestRunner&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="nd"&gt;@Config&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;constants&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BuildConfig&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;buildDir&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;app/build&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ExampleUtilsTest&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

    &lt;span class="nd"&gt;@Test&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;testActivity&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;Exception&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;MainActivity&lt;/span&gt; &lt;span class="n"&gt;mainActivity&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Robolectric&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setupActivity&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MainActivity&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;Assert&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;assertNotNull&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mainActivity&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;这个简单的例子我们先不解析为什么这么写，尝试运行，你可能会遇到以下问题：
- AppCompatActivity问题
- MultiDexApplication问题&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;遇到上述问题请先跳到后面看对应的问题章节，如果你无上述问题，但是运行时一直Download，如下图所示：
&lt;img alt="download" src="../images/robolectricTest/2.jpg"&gt;
&amp;emsp;&amp;emsp;这个是Robolectric执行不同SDK版本运行时需要对应运行库，由于服务器本身比较慢，经常超时，有可能一直卡住，如果你足够耐心可以等待其下载完成，如果你没有耐心，可以先跳过，看后面的“Robolectric依赖库问题”。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;如果上述问题都处理了，就可以看到运行通过了。接下来我们来正式学习Robolectric的用法。&lt;/p&gt;
&lt;h2&gt;Robolectric依赖库问题&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;由于Robolectric的依赖库下载经常超时，我们可以改用手动下载方式去解决，先找到&lt;code&gt;C:\Users\（你的用户名）\.m2\repository\org\robolectric\android-all\&lt;/code&gt;目录为需要下载的依赖库位置，可以Maven参考去下载对应版本：&lt;a href="http://mvnrepository.com/artifact/org.robolectric/android-all"&gt;http://mvnrepository.com/artifact/org.robolectric/android-all&lt;/a&gt;，下载的Jar后先暂停测试进程，然后删除对应的xxx.jar.tmp文件，复制xxx.jar文件进去，重新运行测试即可。&lt;/p&gt;
&lt;h2&gt;AppCompatActivity问题&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;如果你使用的Activity是继承自AppCompatActivity，运行的时候会出现&lt;code&gt;java.lang.IllegalStateException: You need to use a Theme.AppCompat theme (or descendant) with this activity.&lt;/code&gt;问题，遇到这个问题只需要把继承AppCompatActivity的主题改为Theme.Appcompat主题或者他的子主题，比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;activity&lt;/span&gt; 
    &lt;span class="na"&gt;android:name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;.MainActivity&amp;quot;&lt;/span&gt;
    &lt;span class="na"&gt;android:theme=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;@style/Theme.AppCompat.Light&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    //....
&lt;span class="nt"&gt;&amp;lt;/activity&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;MultiDexApplication问题&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;如果你的Application继承自MultiDexApplication就有可能会出现：&lt;code&gt;java.lang.RuntimeException: Multi dex installation failed.&lt;/code&gt;，那是因为你没有添加shadows-multidex依赖库，可以参考前文说的，添加：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;testCompile &amp;quot;org.robolectric:shadows-multidex:3.+&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;测试Activity&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;上面的例子已经展示了通过&lt;code&gt;Robolectric.setupActivity&lt;/code&gt;创建了一个Activity，那么这个setupActivity做了什么呢？下面我们看一下源码，可以看出，实际上setupActivity相当于做了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Robolectric&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;buildActivity&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MainActivity&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;create&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;在Robolectric中，Activity的生命周期由ActivityController来控制，使用buildActivity来创建一个ActivityController，通过查看源码可以看到，调用create()方法，实际上顺序调用了performCreate的方法，实际上就是执行了Activity的onCreate方法。而get()则是获取Activity对象。通过查看ActivityController的源码，可以看出他身上的方法和常用Activity的生命周期对应如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;create()&lt;/strong&gt;--&amp;gt;Activity.onCreate()&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;start()&lt;/strong&gt;--&amp;gt;Activity.onStart()&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;resume()&lt;/strong&gt;--&amp;gt;Activity.onResume()&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pause()&lt;/strong&gt;--&amp;gt;Activity.onPause()&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;stop()&lt;/strong&gt;--&amp;gt;Activity.onStop()&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;destroy()&lt;/strong&gt;--&amp;gt;Activity.onDestory()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;还有其他比如onRestart等的可以参考源代码找到。&lt;/p&gt;
&lt;h2&gt;测试Intent&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;假设有一个MainActivity，上面的btnNext按钮点击后会跳转到NextActivity，我们利用Robolectric来测试这段代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//模拟点击跳转&lt;/span&gt;
&lt;span class="n"&gt;Button&lt;/span&gt; &lt;span class="n"&gt;btnNext&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;mainActivity&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;findViewById&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;id&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;btn_next&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;btnNext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;performClick&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

&lt;span class="c1"&gt;//获取跳转的意图&lt;/span&gt;
&lt;span class="n"&gt;Intent&lt;/span&gt; &lt;span class="n"&gt;actual&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ShadowApplication&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getInstance&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getNextStartedActivity&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

&lt;span class="c1"&gt;//期望意图&lt;/span&gt;
&lt;span class="n"&gt;Intent&lt;/span&gt; &lt;span class="n"&gt;expected&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Intent&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mainActivity&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;NextActivity&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;//假设一致&lt;/span&gt;
&lt;span class="n"&gt;Assert&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;assertEquals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expected&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getComponent&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;actual&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getComponent&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;值得注意的是，如果新版Robolectric使用Assert.assertEquals(expected, actual)来直接对比两个Intent，可能会出现不一致现象。所以只能对比他的组件名，后面会介绍另外一个工具帮助我们快速对比。&lt;/p&gt;
&lt;h2&gt;测试Fragment&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;Fragment和Activity的测试大同小异，值得注意的是如果使用的兼容包要注意导入，代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//非V4包写法&lt;/span&gt;
&lt;span class="n"&gt;BlankFragment&lt;/span&gt; &lt;span class="n"&gt;blankFragment&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Robolectric&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;buildFragment&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BlankFragment&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

&lt;span class="c1"&gt;//兼容V4包写法&lt;/span&gt;
&lt;span class="n"&gt;SuppportFragment&lt;/span&gt; &lt;span class="n"&gt;supportFragment&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;SuppportFragment&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;SupportFragmentTestUtil&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;startFragment&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;supportFragment&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//触发Fragment的onCreateView()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;非V4包buildFragment产生的也是FragmentController，和Activity的结构大体相似，而V4包的则是FragmentManager，这里不一一分析了。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;另外还有测试Service等组件，可以使用对应的buildXxx，比如说使用&lt;code&gt;Robolectric.buildService(Service.class)&lt;/code&gt;来获得ServiceController，剩下的逻辑和上述的测试Activity的大体相同。如果不关心生命周期，可以把组件当做普通类使用测试（不建议）。&lt;/p&gt;
&lt;h2&gt;测试Toast&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;这个看上去似乎没有什么必要的工作，实际上这里是想说明一种测试思想。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="c1"&gt;//上面执行了弹出Toast的代码&lt;/span&gt;
&lt;span class="n"&gt;assertEquals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ShadowToast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getTextOfLatestToast&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;toast content&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;这里举这个简单例子是为了简单说明，如果要获取某个类的状态，可以通过其Shadow类来获取，比如AlertDialog可以通过ShadowAlertDialog来获取弹出的AlertDialog等等。这里就不一一说明了。&lt;/p&gt;
&lt;h2&gt;Application和ShadowApplication&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;code&gt;ShadowApplication.getInstance()&lt;/code&gt;和&lt;code&gt;RuntimeEnvironment.application&lt;/code&gt;两个Application有什么区别呢？我们分析源码看看ShadowApplication.getInstance()的源码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;RuntimeEnvironment&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;application&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;shadowOf&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;RuntimeEnvironment&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;application&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;其中shadowOf是把真实模拟的Application变成Shadow对象，可以提供一些原本没有的方法。例如RuntimeEnvironment.application可以使用getString去获取字符串信息，而ShadowApplication.getInstance()不行，但他可以使用getNextStartedActivity获取下一个启动的Activity等方法。&lt;/p&gt;
&lt;h2&gt;获取Shadow对象&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;假设有一个对象，你想获取它的Shadow对象，可以使用&lt;code&gt;Shadows.shadowOf&lt;/code&gt;，例如上文说到的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="n"&gt;ShadowApplication&lt;/span&gt; &lt;span class="n"&gt;shadowApplication&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Shadows&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;shadowOf&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;RuntimeEnvironment&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;application&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;如果是自定义的Shadow对象则使用&lt;code&gt;Shadow.extract&lt;/code&gt;方法，别急，马上就说明怎么自定义Shadow对象。&lt;/p&gt;
&lt;h2&gt;自定义Shadow对象&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;假设有原始类SampleClass，你想要创建他的Shadow对象，并且想修改和扩展它的方法，原始类代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * 原始类&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SampleClass&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;getString&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;你可以使用Robolectric提供给的@Implements注解说明原始类，使用@Implementation说明该方法为替换原始类中的方法，另外可以随意扩展方法，代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@Implements&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SampleClass&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ShadowSampleClass&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

    &lt;span class="nd"&gt;@Implementation&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;getString&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;     * 扩展的方法&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;getStringEx&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;之后你需要@Config下添加shadows参数说明需要使用的Shadow对象，就可以在代码中使用了，运行的时候单元测试中的SampleClass会被替换成ShadowSampleClass，具体代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@RunWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;RobolectricTestRunner&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="nd"&gt;@Config&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;constants&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BuildConfig&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;buildDir&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;app/build&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;shadows&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="n"&gt;ShadowSampleClass&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;})&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ExampleUtilsTest&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

    &lt;span class="nd"&gt;@Test&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;testShadows&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;Exception&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;SampleClass&lt;/span&gt; &lt;span class="n"&gt;sampleClass&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;SampleClass&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

        &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;original&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sampleClass&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getString&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;123&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;Assert&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;assertEquals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;original&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

        &lt;span class="c1"&gt;//转换出Shadow对象&lt;/span&gt;
        &lt;span class="n"&gt;ShadowSampleClass&lt;/span&gt; &lt;span class="n"&gt;shadowSampleClass&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Shadow&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;extract&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sampleClass&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;Assert&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;assertEquals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;shadowSampleClass&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getStringEx&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;可以发现上述两个assertEquals都是passed的。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;Robolectric给我们带来了非常方便的测试，但是它本身存在比较多的坑，而且版本之间差别也非常大，所以这个玩意还需要大家多琢磨琢磨，尤其是在已有项目中集成可是要费一点时间了。好了，还记得上文说到的Intent不能使用Assert直接判断是否相等吗？下篇给大家介绍一个神器来解决这个问题。&lt;/p&gt;
&lt;h2&gt;相关文章&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Android单元测试之JUnit框架：&lt;/strong&gt;&lt;a href="https://maxwell-nc.github.io/android/junitTest.html"&gt;https://maxwell-nc.github.io/android/junitTest.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Android单元测试之Mockito框架：&lt;/strong&gt;&lt;a href="https://maxwell-nc.github.io/android/mockitoTest.html"&gt;https://maxwell-nc.github.io/android/mockitoTest.html&lt;/a&gt;&lt;/p&gt;</content><category term="android"></category><category term="test"></category><category term="robolectric"></category></entry><entry><title>Android单元测试之Mockito框架</title><link href="https://maxwell-nc.github.io/android/mockitoTest.html" rel="alternate"></link><published>2017-05-25T00:00:00+08:00</published><updated>2017-05-25T00:00:00+08:00</updated><author><name>Maxwell-nc</name></author><id>tag:maxwell-nc.github.io,2017-05-25:/android/mockitoTest.html</id><summary type="html">&lt;h2&gt;前序&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;之前写的&lt;a href="https://maxwell-nc.github.io/android/junitTest.html"&gt;JUnit框架单元测试&lt;/a&gt;的最后留了一个悬念，今天我们把这个问题解决下，首先我们要理解mock的概念，然后学习使用mock来做单元测试。关于Mock的框架有很多，比如Mockito、PowerMock、EasyMock等等，本文主要介绍Mockito的用法，各种框架的对比不在本文阐述范围，而且此类框架大体相同，只需要学习其中一个就能轻松地学习其他框架，没必要纠结那个框架才是最好的。&lt;/p&gt;
&lt;h2&gt;Mock的概念&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;首先要明白什么是Mock，为什么要Mock，Mock能干什么这三个问题。Mock的中文意思是“模仿”，Mock就是去构造（模仿）一个虚拟的对象，而这个对象通常比较难直接创建，有了Mock可以轻松地帮助你对复杂的功能解耦，实现单元测试。比如&lt;a href="https://maxwell-nc.github.io/android/junitTest.html"&gt;前文&lt;/a&gt;最后留下的Log类，你会发现它依赖于Android运行环境，很难把整个依赖树都构建出来，所以我们需要Mock。&lt;/p&gt;
&lt;h2&gt;集成Mocktio&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;Android上集成非常简单，在app项目下的build.gradle添加测试编译依赖(下面采用2.x最新版本)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;dependencies {
    //...
    testCompile &amp;quot;org.mockito:mockito-core:2.+&amp;quot;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;然后使用Gradle Sync一下即可。顺便附上Mockito的Jcenter地址：&lt;a href="http://jcenter.bintray.com/org/mockito/mockito-core/"&gt;http …&lt;/a&gt;&lt;/p&gt;</summary><content type="html">&lt;h2&gt;前序&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;之前写的&lt;a href="https://maxwell-nc.github.io/android/junitTest.html"&gt;JUnit框架单元测试&lt;/a&gt;的最后留了一个悬念，今天我们把这个问题解决下，首先我们要理解mock的概念，然后学习使用mock来做单元测试。关于Mock的框架有很多，比如Mockito、PowerMock、EasyMock等等，本文主要介绍Mockito的用法，各种框架的对比不在本文阐述范围，而且此类框架大体相同，只需要学习其中一个就能轻松地学习其他框架，没必要纠结那个框架才是最好的。&lt;/p&gt;
&lt;h2&gt;Mock的概念&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;首先要明白什么是Mock，为什么要Mock，Mock能干什么这三个问题。Mock的中文意思是“模仿”，Mock就是去构造（模仿）一个虚拟的对象，而这个对象通常比较难直接创建，有了Mock可以轻松地帮助你对复杂的功能解耦，实现单元测试。比如&lt;a href="https://maxwell-nc.github.io/android/junitTest.html"&gt;前文&lt;/a&gt;最后留下的Log类，你会发现它依赖于Android运行环境，很难把整个依赖树都构建出来，所以我们需要Mock。&lt;/p&gt;
&lt;h2&gt;集成Mocktio&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;Android上集成非常简单，在app项目下的build.gradle添加测试编译依赖(下面采用2.x最新版本)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;dependencies {
    //...
    testCompile &amp;quot;org.mockito:mockito-core:2.+&amp;quot;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;然后使用Gradle Sync一下即可。顺便附上Mockito的Jcenter地址：&lt;a href="http://jcenter.bintray.com/org/mockito/mockito-core/"&gt;http://jcenter.bintray.com/org/mockito/mockito-core/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;验证互动（Interactions）&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;下面来使用Mockito验证互动功能，比如说验证TextView的setText方法交互情况：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;TextView&lt;/span&gt; &lt;span class="n"&gt;mockedTextView&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Mockito&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;mock&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TextView&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;mockedTextView&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setText&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;Mockito&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;verify&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mockedTextView&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;setText&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;上述代码的&lt;code&gt;mock&lt;/code&gt;方法用于“模仿”一个对象并返回这个对象，而&lt;code&gt;verify&lt;/code&gt;方法则是用于验证“模仿对象”的互动。&lt;strong&gt;特别注意：如果你使用&lt;code&gt;mockedTextView.getText()&lt;/code&gt;获取设置的值会发现返回值为null&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;设置桩（Stub）&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;上面最后说到&lt;code&gt;mockedTextView.getText()&lt;/code&gt;会返回一个null，假设我们需要测试&lt;code&gt;mockedTextView.getText()&lt;/code&gt;返回值是否正确怎么处理呢？Mockito给我们设置方法桩功能。简单来说就是“指定方法返回的结果”，比如下面代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;TextView&lt;/span&gt; &lt;span class="n"&gt;mockedTextView&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Mockito&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;mock&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TextView&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;Mockito&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;when&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mockedTextView&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getText&lt;/span&gt;&lt;span class="o"&gt;()).&lt;/span&gt;&lt;span class="na"&gt;thenReturn&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mockedTextView&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getText&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;上述代码用&lt;code&gt;when&lt;/code&gt;方法指定要设置桩的方法，&lt;code&gt;thenReturn&lt;/code&gt;来指定返回值，测试后发现输出为“test”，表明设置方法桩成功。值得注意的时候，给方法设置桩可以设置多次，只会返回最后一次设置的值。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;除了when...thenReturn的写法外，还有doRetrun...when的写法，代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Mockito&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;doReturn&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;123&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;when&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mockedTextView&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;getText&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;验证模式（Verification Mode）&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;细心的读者会发现&lt;code&gt;verify&lt;/code&gt;方法重载里另外一个带VerificationMode参数的方法。这个参数用于设置验证模式，比如说需要验证方法执行了多少次。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;VerificationMode是一个接口，我们可以看看源码中实现这个接口的类来学习它的用法：
&lt;img alt="impl" src="../images/mockitoTest/1.jpg"&gt;
&amp;emsp;&amp;emsp;比如Mockito.times(1)代表验证方法执行了1次：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Mockito&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;verify&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mockedTextView&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Mockito&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;times&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)).&lt;/span&gt;&lt;span class="na"&gt;getText&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;其他的验证模式也是大体相同的用法，具体可以参考类的说明。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;注意默认没有验证模式的verify方法使用的默认验证模式就是&lt;/strong&gt;&lt;code&gt;Mockito.times(1)&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;参数匹配器（Argument Matcher)&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;有时候我们不关心输入，比如说setText()方法:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;TextView&lt;/span&gt; &lt;span class="n"&gt;mockedTextView&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Mockito&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;mock&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TextView&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;mockedTextView&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setText&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;Mockito&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;verify&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mockedTextView&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;setText&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Mockito&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;anyString&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;上述的&lt;code&gt;Mockito.anyString()&lt;/code&gt;就是一个参数匹配器，值得注意的是，默认的验证模式是&lt;code&gt;Mockito.times(1)&lt;/code&gt;，如果使用了参数匹配器，注意调用次数，否则回报：&lt;code&gt;org.mockito.exceptions.verification.TooManyActualInvocations&lt;/code&gt;，下面是调用两次的正确例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;TextView&lt;/span&gt; &lt;span class="n"&gt;mockedTextView&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Mockito&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;mock&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TextView&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;mockedTextView&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setText&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;mockedTextView&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setText&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;Mockito&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;verify&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mockedTextView&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Mockito&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;times&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;)).&lt;/span&gt;&lt;span class="na"&gt;setText&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Mockito&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;anyString&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;由于参数匹配器的种类太多，这里就不一样列举了，可以参考ArgumentMatchers类找到各种匹配器。&lt;/p&gt;
&lt;h2&gt;抛出异常&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;若果需要某个方法抛出异常，可以使用下面的方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//void返回方法
Mockito.doThrow(new RuntimeException()).when(mockedTextView).setText(&amp;quot;abc&amp;quot;);

//非void返回方法
Mockito.when(mockedTextView.getText()).thenThrow(new RuntimeException());
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;其中注意区分不同返回类型的写法不同。另外如果需要防止异常中断执行，可以在增加一个doNothing方法，代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Mockito.doNothing().doThrow(new NullPointerException()).when(mockedTextView).setText(&amp;quot;abc&amp;quot;);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;可以看到上述代码，&lt;strong&gt;只有Void返回类型方法&lt;/strong&gt;才能使用&lt;code&gt;doNothing()&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;自定义应答（Answer）&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;对于一个方法设置桩when...thenXxx或者doXxxx...when的组合外，Mockito给了一个自定义应答的的方法让我们自定义方法应答的内容。试想一下，假设有一个异步方法（当然返回类型就是Void）的回调中有多个回调，当你想指定执行某个回调之前学到的显然就不那么容易实现了。如果自定义Answer内容，那将是非常简单的，示例代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Mockito&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;doAnswer&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Answer&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="nf"&gt;answer&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InvocationOnMock&lt;/span&gt; &lt;span class="n"&gt;invocationOnMock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;Throwable&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

        &lt;span class="c1"&gt;//获取第一个参数&lt;/span&gt;
        &lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="n"&gt;callback&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;invocationOnMock&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getArgument&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

        &lt;span class="c1"&gt;//指定回调执行操作&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;callback&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;onFinished&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;}).&lt;/span&gt;&lt;span class="na"&gt;when&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mockedClass&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;asyncRequset&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;callback&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;&lt;span class="c1"&gt;//执行一步操作&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;或者举一个简单的例子(采用when...thenAnswer方式)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Mockito&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;when&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mockedTextView&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getText&lt;/span&gt;&lt;span class="o"&gt;()).&lt;/span&gt;&lt;span class="na"&gt;thenAnswer&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Answer&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="nd"&gt;@Override&lt;/span&gt;
            &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;answer&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InvocationOnMock&lt;/span&gt; &lt;span class="n"&gt;invocationOnMock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;Throwable&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;custom answer&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
            &lt;span class="o"&gt;}&lt;/span&gt;
        &lt;span class="o"&gt;});&lt;/span&gt;
&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;print&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mockedTextView&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getText&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;很明显，这里最终输出为:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;custom answer
test
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;间谍（Spy）&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;要知道如果Mock一个对象后，这个&lt;strong&gt;Mock对象对于所有非Void返回方法将返回默认值（对象则返回null），所有Void方法将什么都不做&lt;/strong&gt;。如果要保留原来对象的功能，而仅仅修改一个或几个方法的返回值，可以采用Spy方法，具体代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;ArrayList&lt;/span&gt; &lt;span class="n"&gt;spyArray&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Mockito&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;spy&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ArrayList&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
&lt;span class="n"&gt;spyArray&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;add&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;spyArray&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;add&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;Mockito&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;when&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;spyArray&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)).&lt;/span&gt;&lt;span class="na"&gt;thenReturn&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//注意书写位置，否则报IndexOutOfBound&lt;/span&gt;
&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;spyArray&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;&lt;span class="c1"&gt;//输出1&lt;/span&gt;
&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;print&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;spyArray&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;&lt;span class="c1"&gt;//输出2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;上述代码可以看到Spy方法没有改变ArrayList里的方法，只是当get(0)时返回1，其他方法执行逻辑还是ArrayList中的逻辑。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;特别注意这个Spy方法看上去似乎很方便，实际上如果你Spy一个需要Mock的对象，就会提示你该对象没有Mock，就比如TextView。&lt;/p&gt;
&lt;h2&gt;Mock注解（Annotation）&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;使用@Mock可以帮我们快速Mock对象：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;AnnotationTest&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

    &lt;span class="nd"&gt;@Mock&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="n"&gt;TextView&lt;/span&gt; &lt;span class="n"&gt;mockedTextView&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

    &lt;span class="nd"&gt;@Before&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setup&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;MockitoAnnotations&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;initMocks&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//初始化所有Mock注解&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;如果觉得写setup方法比较麻烦，可以去掉并使用Mockito自带的JUnit Rule帮我们自动完成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;AnnotationTest&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

    &lt;span class="nd"&gt;@Rule&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;MockitoRule&lt;/span&gt; &lt;span class="n"&gt;mockitoRule&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MockitoJUnit&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;rule&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="nd"&gt;@Mock&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="n"&gt;TextView&lt;/span&gt; &lt;span class="n"&gt;mockedTextView&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;如果没有使用JUnit Runner，可以直接使用Mockito提供的JUnitRunner（Runner相当于一个容器，负责处理你的测试代码）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@RunWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MockitoJUnitRunner&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;AnnotationTest&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

    &lt;span class="nd"&gt;@Mock&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="n"&gt;TextView&lt;/span&gt; &lt;span class="n"&gt;mockedTextView&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;另外Mockito还提供了其他注解，例如@Spy，这个可以用于&lt;strong&gt;无参构造&lt;/strong&gt;的类初始化Spy，所以实用性并不高，其他一些不常用的这里就不介绍了。&lt;/p&gt;
&lt;h2&gt;静态方法处理&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;实际上即使你看完前面全部内容，还是不能解决我们&lt;a href="https://maxwell-nc.github.io/android/junitTest.html"&gt;上一篇文章&lt;/a&gt;最后提到的那个问题，因为&lt;strong&gt;Mockito不支持静态方法的Mock&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;要Mock静态方法有两个方法，一个是使用PowerMock来扩展Mockito，另外一个就是创建一个StaticWrapper来把静态方法变成非静态方法，方法如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;LogTest&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

    &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;StaticWrapper&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="c1"&gt;//包裹静态方法为非静态方法&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;i&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;tag&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;Log&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;i&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tag&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="nd"&gt;@Test&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;StaticWrapper&lt;/span&gt; &lt;span class="n"&gt;mockedLog&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Mockito&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;mock&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StaticWrapper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;mockedLog&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;i&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;Mockito&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;verify&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mockedLog&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;i&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;尾声&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;上文介绍了Mockito所有基本用法，但是这还不是Mockito的全部，感兴趣的可以自己深入研究一下，例如InOrder的用法等等。虽然我们已经学会了Mockito和JUnit，但是要在JVM上测试Android代码（比如要测试Activity的生命周期），显然之前学的无法解决这个问题。这里又留下一个悬念，下篇文章我们再来探讨这个问题。&lt;/p&gt;
&lt;h2&gt;相关文章&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Android单元测试之JUnit框架：&lt;/strong&gt;&lt;a href="https://maxwell-nc.github.io/android/junitTest.html"&gt;https://maxwell-nc.github.io/android/junitTest.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mockito Github：&lt;/strong&gt;&lt;a href="https://github.com/mockito/mockito"&gt;https://github.com/mockito/mockito&lt;/a&gt;&lt;/p&gt;</content><category term="android"></category><category term="test"></category><category term="mockito"></category></entry><entry><title>快速集成ReactNative到现有Android项目</title><link href="https://maxwell-nc.github.io/android/rnIntergation.html" rel="alternate"></link><published>2017-05-24T00:00:00+08:00</published><updated>2017-05-24T00:00:00+08:00</updated><author><name>Maxwell-nc</name></author><id>tag:maxwell-nc.github.io,2017-05-24:/android/rnIntergation.html</id><summary type="html">&lt;h2&gt;前序&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;突然想起来之前旧博客的&lt;a href="http://blog.csdn.net/maxwell_nc/article/details/60960864"&gt;《Windows下搭建ReactNative开发环境（Android）》&lt;/a&gt;留下的一个坑，遂填一下坑。而且集成ReactNative到现有Android项目也不是什么容易的事情，网上很多教程都是不完整，你会发现跟着来做都是一步一个坑，不断搜索error解决花了半天才能搭建好，下次再做又是一堆问题，所以我这里记录下自己的集成心得。&lt;/p&gt;
&lt;h2&gt;准备操作&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;首先你建议你先看看&lt;a href="http://blog.csdn.net/maxwell_nc/article/details/60960864"&gt;上一篇搭建环境的文章&lt;/a&gt;，否则接下来的内容你可以看不懂或者没有对应的工具。然后就是你需要有一个现有的Android项目，如果你需要创建全新项目前一篇已经描述过了，本文就不再重复了。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;本文集成的&lt;strong&gt;ReactNative版本为0.44&lt;/strong&gt;，如果不是的话可能与本文内容有所差异，请自行甄别。&lt;/p&gt;
&lt;h2&gt;安装ReactNative到项目&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;我们已一个已存在的工程ExistedProject为例，首先打开项目的目录，在CMD输入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;npm init
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;&lt;code&gt;npm init&lt;/code&gt;会提示引导你创建package.json,如下图所示：
&lt;img alt="init" src="../images/rnIntergation/1.jpg"&gt;
&amp;emsp;&amp;emsp;创建成功后可以安装React、ReactNative到目录里面，继续在&lt;strong&gt;当前目录&lt;/strong&gt;下输入命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;npm install --save react react-native
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;等待安装成功的过程中，可以到&lt;a href="https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig"&gt;https://raw.githubusercontent …&lt;/a&gt;&lt;/p&gt;</summary><content type="html">&lt;h2&gt;前序&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;突然想起来之前旧博客的&lt;a href="http://blog.csdn.net/maxwell_nc/article/details/60960864"&gt;《Windows下搭建ReactNative开发环境（Android）》&lt;/a&gt;留下的一个坑，遂填一下坑。而且集成ReactNative到现有Android项目也不是什么容易的事情，网上很多教程都是不完整，你会发现跟着来做都是一步一个坑，不断搜索error解决花了半天才能搭建好，下次再做又是一堆问题，所以我这里记录下自己的集成心得。&lt;/p&gt;
&lt;h2&gt;准备操作&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;首先你建议你先看看&lt;a href="http://blog.csdn.net/maxwell_nc/article/details/60960864"&gt;上一篇搭建环境的文章&lt;/a&gt;，否则接下来的内容你可以看不懂或者没有对应的工具。然后就是你需要有一个现有的Android项目，如果你需要创建全新项目前一篇已经描述过了，本文就不再重复了。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;本文集成的&lt;strong&gt;ReactNative版本为0.44&lt;/strong&gt;，如果不是的话可能与本文内容有所差异，请自行甄别。&lt;/p&gt;
&lt;h2&gt;安装ReactNative到项目&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;我们已一个已存在的工程ExistedProject为例，首先打开项目的目录，在CMD输入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;npm init
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;&lt;code&gt;npm init&lt;/code&gt;会提示引导你创建package.json,如下图所示：
&lt;img alt="init" src="../images/rnIntergation/1.jpg"&gt;
&amp;emsp;&amp;emsp;创建成功后可以安装React、ReactNative到目录里面，继续在&lt;strong&gt;当前目录&lt;/strong&gt;下输入命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;npm install --save react react-native
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;等待安装成功的过程中，可以到&lt;a href="https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig"&gt;https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig&lt;/a&gt;下载&lt;code&gt;.flowconfig&lt;/code&gt;文件复制到项目之中。（这个文件只是用来约束Javascript代码，也可以跳过），很快就安装完成了：
&lt;img alt="warn" src="../images/rnIntergation/2.jpg"&gt;
&amp;emsp;&amp;emsp;这里需要有一个警告：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;react&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;native&lt;/span&gt;&lt;span class="mf"&gt;@0.44.0&lt;/span&gt; &lt;span class="n"&gt;requires&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;peer&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;react&lt;/span&gt;&lt;span class="mf"&gt;@16.0.0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;alpha&lt;/span&gt;&lt;span class="mf"&gt;.6&lt;/span&gt; &lt;span class="n"&gt;but&lt;/span&gt; &lt;span class="n"&gt;none&lt;/span&gt; &lt;span class="n"&gt;was&lt;/span&gt; &lt;span class="n"&gt;installed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;很多的文章都没有说明这个，导致后面项目运行后会出错。遇到这个问题是因为ReactNative和React的版本有着严格的对应关系，如果不一样就会报错，解决方法就是重新安装对应的React版本，输入命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;npm&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;save&lt;/span&gt; &lt;span class="n"&gt;react&lt;/span&gt;&lt;span class="mf"&gt;@16.0.0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;alpha&lt;/span&gt;&lt;span class="mf"&gt;.6&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;这样就可以避免后面出现的这两个问题:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Unable to resolve module `react/lib/ReactDebugCurrentFrame`
Unable to resolve module `react/lib/ReactComponentWithPureRenderMixin`
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;接下来修改package.json文件,在&lt;code&gt;"scripts"&lt;/code&gt;下增加一句&lt;code&gt;"start": "node node_modules/react-native/local-cli/cli.js start"&lt;/code&gt;,注意json格式，需要添加逗号，最后package.json文件应该是这样的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;ext_prj&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;version&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;1.0.0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;description&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;nothing&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;main&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;index.js&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;scripts&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;start&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;node node_modules/react-native/local-cli/cli.js start&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;echo \&amp;quot;Error: no test specified\&amp;quot; &amp;amp;&amp;amp; exit 1&amp;quot;&lt;/span&gt;
  &lt;span class="p"&gt;},&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;author&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;maxwell-nc&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;license&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;ISC&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;dependencies&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;react&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;^16.0.0-alpha.6&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;react-native&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;^0.44.0&amp;quot;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;创建安卓首页js文件&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;接下来在项目目录中创建index.android.js文件，然后编辑内容：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nx"&gt;React&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;Component&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="nx"&gt;from&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;react&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;AppRegistry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;Text&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="nx"&gt;from&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;react-native&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;HelloWorld&lt;/span&gt; &lt;span class="kr"&gt;extends&lt;/span&gt; &lt;span class="nx"&gt;Component&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nx"&gt;render&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
      &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;Text&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nx"&gt;Hello&lt;/span&gt; &lt;span class="nx"&gt;world&lt;/span&gt;&lt;span class="o"&gt;!&amp;lt;&lt;/span&gt;&lt;span class="err"&gt;/Text&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;//这里的&amp;#39;HelloWorld&amp;#39;是后面android项目使用的&lt;/span&gt;
&lt;span class="c1"&gt;//而后面的HelloWorld是class的名称&lt;/span&gt;
&lt;span class="nx"&gt;AppRegistry&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;registerComponent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;HelloWorld&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;HelloWorld&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;留意注释里面的内容，后面有用到，这个文件是react页面的启动页。基本的框架已经搭建好，下面我们配置android项目的设置。&lt;/p&gt;
&lt;h2&gt;配置Android项目&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;首先在android项目目录下的build.gradle文件添加依赖Maven仓库，代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;allprojects {
    repositories {
        maven {
            url &amp;quot;$rootDir/node_modules/react-native/android&amp;quot;
        }
        jcenter()
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;这里又要注意了，node_modules目录的位置必须正确，否则Gradle就会报错误了。然后修改app目录下的build.gradle文件，添加ReactNative依赖：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;dependencies {
    //...
    compile &amp;quot;com.facebook.react:react-native:+&amp;quot;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;为了防止64位库问题和findbugsbug版本问题，同时增加下面的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;android {
    //...
    defaultConfig {
        //...
        ndk{
            abiFilters &amp;quot;armeabi-v7a&amp;quot;,&amp;quot;armeabi-v7a&amp;quot;,&amp;quot;x86&amp;quot;
        }
    }
    //...
    configurations.all {
        resolutionStrategy.force &amp;#39;com.google.code.findbugs:jsr305:3.0.0&amp;#39;
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;如果没有设置，后面可能会产生如下类似问题：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Error&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;Conflict&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;dependency&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;com.google.code.findbugs:jsr305&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;lang&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;UnsatisfiedLinkError&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;could&lt;/span&gt; &lt;span class="n"&gt;find&lt;/span&gt; &lt;span class="n"&gt;DSO&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;load&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;libreactnativejni&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;so&lt;/span&gt;
&lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;lang&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;UnsatisfiedLinkError&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dlopen&lt;/span&gt; &lt;span class="n"&gt;failed&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;xxx/libgnustl_shared.so&amp;quot;&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bit&lt;/span&gt; &lt;span class="n"&gt;instead&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bit&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;配置完Gradle之后执行以下Sync操作确保上述操作无误，然后给AndroidManifest.xml文件添加上网路权限，和DevSettingsActivity界面配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;uses-permission&lt;/span&gt; &lt;span class="na"&gt;android:name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;android.permission.INTERNET&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;

&lt;span class="nt"&gt;&amp;lt;activity&lt;/span&gt; &lt;span class="na"&gt;android:name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;com.facebook.react.devsupport.DevSettingsActivity&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;DevSettingsActivity这个界面在Release的时候可以去掉，仅仅用于开发测试设置。&lt;/p&gt;
&lt;h2&gt;Andorid调用ReactNative&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;首先需要创建一个基类，方便后面使用，这里给大家写了一个BaseReactActivity：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * ReactNativeActivity基类&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;abstract&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BaseReactActivity&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Activity&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;DefaultHardwareBackBtnHandler&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

    &lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="n"&gt;ReactRootView&lt;/span&gt; &lt;span class="n"&gt;mReactRootView&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="n"&gt;ReactInstanceManager&lt;/span&gt; &lt;span class="n"&gt;mReactInstanceManager&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;onCreate&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nd"&gt;@Nullable&lt;/span&gt; &lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="n"&gt;savedInstanceState&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;onCreate&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;savedInstanceState&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;mReactInstanceManager&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ReactInstanceManager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;builder&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
                &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setApplication&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;getApplication&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt;
                &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setBundleAssetName&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;index.android.bundle&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
                &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setJSMainModuleName&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;index.android&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
                &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addPackage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MainReactPackage&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt;
                &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setUseDeveloperSupport&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BuildConfig&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;DEBUG&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
                &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setInitialLifecycleState&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LifecycleState&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;RESUMED&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
                &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;build&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;     * 加载ReactNative内容&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;loadReact&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//这里的HelloWorld必须对应“index.android.js”中的“AppRegistry.registerComponent()”的第一个参数&lt;/span&gt;
        &lt;span class="n"&gt;mReactRootView&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;startReactApplication&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mReactInstanceManager&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;HelloWorld&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;invokeDefaultOnBackPressed&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;onBackPressed&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;onPause&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;onPause&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mReactInstanceManager&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;mReactInstanceManager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;onHostPause&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;onResume&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;onResume&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mReactInstanceManager&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;mReactInstanceManager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;onHostResume&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;onDestroy&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;onDestroy&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mReactInstanceManager&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;mReactInstanceManager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;onHostDestroy&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;onBackPressed&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mReactInstanceManager&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;mReactInstanceManager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;onBackPressed&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;onBackPressed&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;注意代码中startReactApplication方法中的参数要与前面index.android.js文件中设置的一样（看注释），然后根据官方的文档，这个ReactInstanceManager可以设置成一个单例，全局使用同一个ReactInstanceManager就可以了，这里为了方便快捷就写在一起了。这个类主要传递了声明周期给ReactNative，也处理了后退按钮事件。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;注意上面的类中BuildConfig的导包是选择自己的包名，而不是其他：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;com.github.maxwell.nc.existedproject.BuildConfig&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;下面需要把使用到ReactNative的Activity继承这个Activity，如果需要这个ContentView使用ReactRootView，可以在onCreate中添加：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;setContentView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mReactRootView&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ReactRootView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;如果是在布局中增加了ReactRootView，可以使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;setContentView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;layout&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;activity_main&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;mReactRootView&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ReactRootView&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;findViewById&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;id&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;rrv_content&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;然后可以调用&lt;code&gt;loadReact();&lt;/code&gt;去加载ReactNative内容。&lt;/p&gt;
&lt;h2&gt;Android打包&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;前面的操作完成后就基本完成了，现在需要打包一份离线JSBundle进去App，用于没网的时候App展示使用。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;首先在项目app/src/main下面必须要创建一个assets目录，否则后面生成会报&lt;code&gt;ENOENT: no such file or directory, open 'E:\Project\ExistedProject\app\src\main\assets\index.android.bundle'&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;然后在项目目录下打开CMD，输入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;react-native bundle --platform android --dev false --entry-file index.android.js --bundle-output app/src/main/assets/index.android.bundle --assets-dest app/src/main/res/
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;看到&lt;code&gt;Done writing bundle output&lt;/code&gt;就证明生成成功了。接下来直接运行App到手机上看看效果，成功看到离线内容。
&lt;img alt="result" src="../images/rnIntergation/3.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;启动服务器&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;上面的查看效果是离线JSBundle的效果，如果你尝试reload的话就会发现出现error，因为连接不上服务器。直接在目录下输入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;npm start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;启动服务器后不要关闭CMD，手机App注意设置Debug server host &amp;amp; port为主机的地址（具体可以参考我的&lt;a href="http://blog.csdn.net/maxwell_nc/article/details/60960864"&gt;上一篇博文&lt;/a&gt;）,然后reload，看到App绿色的进度条或者服务器CMD中build的进度条就知道正在构建。成功后就可以看到服务器端的js效果。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;可以尝试修改提示语为“Hello ReactNative For Android!”并且保存，手机端reload既可以看到app端更新了的效果：
&lt;img alt="update" src="../images/rnIntergation/4.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;注意你修改了资源可以不重新打包离线JSBundle进去，但是至少需要一份离线JSBundle才能运行App，否则Gradle编译无法通过。&lt;/p&gt;
&lt;h2&gt;远程调试&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;如果你选在手机选择“Debug JS Remotely”，如果你没有安装chrome浏览器，不出意外就是npm服务器提示：
&lt;img alt="update" src="../images/rnIntergation/5.jpg"&gt;
&amp;emsp;&amp;emsp;然后手机端也红屏提示错误，实际上你只需要用任一款chrome壳浏览器打开&lt;a href="http://localhost:8081/debugger-ui"&gt;http://localhost:8081/debugger-ui&lt;/a&gt;然后重新reload，看到&lt;code&gt;Status: Debugger session #0 active.&lt;/code&gt;就可以连上远程调试了，调试不是本文的内容就不再阐述了。&lt;/p&gt;
&lt;h2&gt;尾声&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;ReactNative集成的过程中有很多的坑，如果你按照我的博文来操作可能你会说：“不会啊，一路流程非常轻松没问题啊”,但实际上本博文只是把可能的遇到问题和处理地方已经提前说明了。其中遇到的错误本文也列出来了，方便后面遇到的朋友也参考学习下。&lt;/p&gt;
&lt;h2&gt;相关文章&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Windows下搭建ReactNative开发环境（Android）：&lt;/strong&gt;&lt;a href="http://blog.csdn.net/maxwell_nc/article/details/60960864"&gt;http://blog.csdn.net/maxwell_nc/article/details/60960864&lt;/a&gt;&lt;/p&gt;</content><category term="android"></category><category term="react-native"></category></entry><entry><title>Android单元测试之JUnit框架</title><link href="https://maxwell-nc.github.io/android/junitTest.html" rel="alternate"></link><published>2017-05-22T00:00:00+08:00</published><updated>2017-05-22T00:00:00+08:00</updated><author><name>Maxwell-nc</name></author><id>tag:maxwell-nc.github.io,2017-05-22:/android/junitTest.html</id><summary type="html">&lt;h2&gt;前序&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;最近抽空整理下项目，顺手整理了单元测试，于是记录下自己学习单元测试的心得，让更多的人快速用上单元测试提高开发效率。本文主要讲解如何使用JUnit框架进行单元测试，不会提及单元测试优缺点。&lt;/p&gt;
&lt;h2&gt;在Android项目中使用JUnit&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;记得在Eclipse中集成Junit框架是一件很复杂的事情，首先要导入lib包，然后配置...现在如果使用Android Studio的话什么工作都不需要处理，创建一个新的项目就帮你配置好整个JUnit框架，你只需要专心写测试类即可。而且测试类也是可以自动生成的,如下图所示：
&lt;img alt="dir" src="../images/junitTest/1.jpg"&gt;
&amp;emsp;&amp;emsp;可以看到生成&lt;code&gt;app/src/main&lt;/code&gt;为源码目录，对应&lt;code&gt;app/src/test&lt;/code&gt;为测试类目录，Android Studio会自动生成一个ExampleUnitTest类，实际上这个test目录下的包名可以与src目录的不一样。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;以上图为例，我写了一个ExampleUtils作为本次测试例子，其代码为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ExampleUtils&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

    &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;     * 获取完整的地址路径&lt;/span&gt;
&lt;span class="cm"&gt;     *&lt;/span&gt;
&lt;span class="cm"&gt;     * @param url 可能不完整的路径&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;getFullUrl&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(!&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;startsWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h2&gt;前序&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;最近抽空整理下项目，顺手整理了单元测试，于是记录下自己学习单元测试的心得，让更多的人快速用上单元测试提高开发效率。本文主要讲解如何使用JUnit框架进行单元测试，不会提及单元测试优缺点。&lt;/p&gt;
&lt;h2&gt;在Android项目中使用JUnit&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;记得在Eclipse中集成Junit框架是一件很复杂的事情，首先要导入lib包，然后配置...现在如果使用Android Studio的话什么工作都不需要处理，创建一个新的项目就帮你配置好整个JUnit框架，你只需要专心写测试类即可。而且测试类也是可以自动生成的,如下图所示：
&lt;img alt="dir" src="../images/junitTest/1.jpg"&gt;
&amp;emsp;&amp;emsp;可以看到生成&lt;code&gt;app/src/main&lt;/code&gt;为源码目录，对应&lt;code&gt;app/src/test&lt;/code&gt;为测试类目录，Android Studio会自动生成一个ExampleUnitTest类，实际上这个test目录下的包名可以与src目录的不一样。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;以上图为例，我写了一个ExampleUtils作为本次测试例子，其代码为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ExampleUtils&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

    &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;     * 获取完整的地址路径&lt;/span&gt;
&lt;span class="cm"&gt;     *&lt;/span&gt;
&lt;span class="cm"&gt;     * @param url 可能不完整的路径&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;getFullUrl&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(!&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;startsWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;http://&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;如果你要创建一个对应的测试类，比较笨的方法就是到&lt;code&gt;app/src/test&lt;/code&gt;目录下创建一个名字相近的ExampleUtilsTest类，然后一个个需要测试的方法都写一遍testXXX()的单元测试方法。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;强大的Android Studio可以帮我们完成这个操作，在任意需要测试的类（或者方法）下面按下Ctrl+Shift+T（这是默认热键，你也可以右键-&amp;gt;Go To-&amp;gt;Test）弹出如下提示：
&lt;img alt="hint" src="../images/junitTest/2.jpg"&gt;
&amp;emsp;&amp;emsp;如果你已经创建过，则会提示对应的测试类让你跳转过去，同样测试类也可以利用这个方法跳转到被测试类。根据上述操作创建一个新的测试类，然后会弹出提示界面：
&lt;img alt="new" src="../images/junitTest/3.jpg"&gt;
&amp;emsp;&amp;emsp;我们使用的库是JUnit4，这个无需修改，一般名字Class Name也无需修改，Generate这个后文再说，总之现在Member中勾选需要测试的方法。注意如果一个方法没有出现在这个列表上，证明这个方法无法测试。比如一个private声明的方法，他不需要测试也无法测试，因为它是属于类内部的过程，而单元测试不关系这个过程。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;选择方法后会提示你选择目标目录，可能为了兼容以前的版本还是怎么的，这里我们只需要选择第二个&lt;code&gt;app/src/test&lt;/code&gt;目录，与Android Studio自动生成的目录相似即可：
&lt;img alt="choose" src="../images/junitTest/4.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;可以看到生成的类，有些人可能喜欢改成testXXX，这个则需要自己手动修改了。点击每个方法前面的三角形就可以单独测试一个方法，点击类前面的两个三角形按钮则是一次运行类中所有的测试方法：
&lt;img alt="sample" src="../images/junitTest/5.jpg"&gt;
&amp;emsp;&amp;emsp;我们可以编写单元测试方法（Assert用法后文会说明）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nd"&gt;@Test&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;getFullUrl&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;Exception&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;testUrl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;https://maxwell-nc.github.io&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;fullUrl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ExampleUtils&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getFullUrl&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;testUrl&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;Assert&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;assertEquals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;testUrl&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fullUrl&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//假设fullUrl与testUrl相同&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;点击Run后则会生成一个测试结果，如果一条绿条就证明已经成功通过测试了，否则的话你可以查看哪一个方法存在问题，然后处理。
&lt;img alt="pass" src="../images/junitTest/6.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;批量测试和生产报告&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;假设你只有一个类或者只有几个类需要测试的话，那可以直接使用上文说的方法来测试，但是假设你有很多的类和方法需要测试的话上面的操作就显得是十分笨拙。Android Studio的Gradle插件为我们生成了三个任务：
- testDebugUnitTest
- testReleaseUnitTest
- test
&amp;emsp;&amp;emsp;其中前两个任务是分别执行为Debug和Release模式下的所有单元测试，第三个任务就是执行前面两个任务。
&amp;emsp;&amp;emsp;你可以在Terminal里面使用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gradlew testDebugUnitTest
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;来执行命令，由于是Wrapper可能需要额外的下载配置时间，也可以直接在面板中选择Task执行（使用本地的Gradle）：
&lt;img alt="task" src="../images/junitTest/7.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;等待执行完成就可以看到&lt;code&gt;build/reports/tests/&lt;/code&gt;目录下对应的Html报告：
&lt;img alt="build" src="../images/junitTest/8.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;使用浏览器打开可以看到详细测试报告：
&lt;img alt="report" src="../images/junitTest/9.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;JUnit Assert&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;下面进入正题，上文我们使用了一个Assert.assertEquals方法来判断fullUrl和testUrl是否相同，其中这个Assert类就是用来验证结果的，有“假设”的意思。比如assertEquals方法就是“假设相同”的意思，如果不相同则会报错。
&amp;emsp;&amp;emsp;那么除了assertEquals之外还有什么方法呢？我们可以从Assert源码结构观察出来，下面我们列举一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;assertTrue&lt;/strong&gt; 假设为真&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;assertFalse&lt;/strong&gt; 假设为假&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;assertEquals&lt;/strong&gt; 假设相同（基本数据类型或者对象）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;assertNotEquals&lt;/strong&gt; 假设不相同（基本数据类型或者对象）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;assertNull&lt;/strong&gt; 假设为空&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;assertNotNull&lt;/strong&gt; 假设不为空&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;assertSame&lt;/strong&gt; 假设相同（只能是对象）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;assertNotSame&lt;/strong&gt; 假设不相同（只能是对象）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;assertArrayEquals&lt;/strong&gt; 假设数组相同&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;可以看到源码中这些方法都有重载第一个参数多了String的方法。这个String是用于自定义错误信息，如果“假设”不符合预期，那么提示的错误信息使用这个String来指定。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;有时候计算机表示的数尤其是浮点型类型，可能两个值存在误差，设置一个可接受无法范围，也可以让假设通过。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Assert&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;assertEquals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.01&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;上面表示预期值和实际值最大误差小于等于0.1即“假设”成立。另外注意这些方法的期望值都是前一个参数，实际值是后一个参数，不要写反了。&lt;/p&gt;
&lt;h2&gt;JUnit Annotation&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;还记得上边创建测试类的时候出现了setUp和tearDown两个方法吗？分别对应@Before和@After这两个注解。实际上根据JUnit框架的设计，每个单元测试方法可以简单划分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;setUp&lt;/strong&gt; 对应 @Before注解的方法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;test&lt;/strong&gt;  对应 @Test注解的方法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tearDown&lt;/strong&gt; 对应 @After注解的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;如果创建时勾选这两个方法，则会生成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@Before&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setUp&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;Exception&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="nd"&gt;@After&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;tearDown&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;Exception&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;这两个方法会在当前类中&lt;strong&gt;每一个单元测试方法&lt;/strong&gt;执行之前和执行之后分别执行。比如说需要创建一个实例，new instance()操作可以直接写在setUp方法中，减少冗余代码。同理假设要关闭一个文件流的话也可以写在tearDown方法中。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;注意看看@Test注解的注释，可以看到，它可以接受两个参数，一个是预期异常，一个是超时时间。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//预期异常，不报错（如果不出现异常则报错）&lt;/span&gt;
&lt;span class="nd"&gt;@Test&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expected&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;IndexOutOfBoundsException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;outOfBounds&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ArrayList&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;//超时报错&lt;/span&gt;
&lt;span class="nd"&gt;@Test&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;infinity&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;//这种情况要小心，注意误差问题，有可能正确，有可能错误&lt;/span&gt;
&lt;span class="nd"&gt;@Test&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;sleep100&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sleep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;除了上述的注解之外，JUnit还提供其他很多方便的注解，我们可以通过查看JUnit的包看到比较常用的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;@BeforeClass&lt;/strong&gt; 每一个测试类执行前的操作方法注解&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@AfterClass&lt;/strong&gt; 每一个测试类执行完后的操作方法注解&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@Ignore&lt;/strong&gt; 忽略某个测试方法注解（可以传入原因)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;由于JUnit担心我们这些注解还不够用，所以给我们自定义规则的机会，于是有@Rule这个注解给我们去自定义规则。&lt;/p&gt;
&lt;h2&gt;JUnit Rule&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;JUnit本身自带很多Rule，可以在org.junit.rules包中找到,例如比较简单的Timeout规则，可以直接创建一个类成员：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@Rule&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Timeout&lt;/span&gt; &lt;span class="n"&gt;timeout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Timeout&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TimeUnit&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;MILLISECONDS&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;上述规则应用到类中所有测试方法，假设方法超过100毫秒则会报错，注意这个成员规则对象必须是Public的，还有一个比较常用的DisableOnDebug规则，可以设置在Run模式下使用的规则而Debug模式不使用的规则，如下代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@Rule&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;DisableOnDebug&lt;/span&gt; &lt;span class="n"&gt;debug&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;DisableOnDebug&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Timeout&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TimeUnit&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;MILLISECONDS&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;上述代码表示Run模式测试则会限制100毫秒超时，而Debug模式不会限制。虽然JUnit给我们内置了很多自定义规则，但这显然是不够用的，所以需要我们去自定义规则，下面我们来说说如何自定义Junit Rule。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;在rules包下有一个TestRule接口用于给用户自定义Junit Rule，创建一个类去实现这个接口。然后重写apply方法。代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyTestRule&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;TestRule&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Statement&lt;/span&gt; &lt;span class="nf"&gt;apply&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Statement&lt;/span&gt; &lt;span class="n"&gt;base&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Description&lt;/span&gt; &lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;其中apply方法中的base参数代表单元测试的语句，他身上的方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;base&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;evaluate&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;&lt;span class="c1"&gt;//执行单元测试操作&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;而description则可以获取改单元测试方法的名称、注解、类名等等的描述。我们可以写一个简单的例子，如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@Override&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Statement&lt;/span&gt; &lt;span class="nf"&gt;apply&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="n"&gt;Statement&lt;/span&gt; &lt;span class="n"&gt;base&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Description&lt;/span&gt; &lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Statement&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="nd"&gt;@Override&lt;/span&gt;
        &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;evaluate&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;Throwable&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;before&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//测试前打印before&lt;/span&gt;
            &lt;span class="n"&gt;base&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;evaluate&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;print&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;after&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//测试后打印after&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;};&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;然后在需要使用这个规则的测试类中声明这个规则：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@Rule&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;MyTestRule&lt;/span&gt; &lt;span class="n"&gt;myTestRule&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MyTestRule&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;运行测试方法即即可以看到输出：
&lt;img alt="out" src="../images/junitTest/10.jpg"&gt;
&amp;emsp;&amp;emsp;这样代表自定义的规则生效了。&lt;/p&gt;
&lt;h2&gt;尾声&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;通过上文，我们学习了JUnit的用法，但是你会发现，光有JUnit框架并不能做完整的单元测试，比如说你想要使用&lt;code&gt;Log.i("tag","msg");&lt;/code&gt;的时候，单元测试会失败并且提示:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;java.lang.RuntimeException: Method i in android.util.Log not mocked.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;这是因为JUnit并不能在纯Java层面做测试，使用非纯Java API就会报错。这需要一些Mock框架来帮助我们进行测试，这个后面抽空会写一篇新的博文介绍。&lt;/p&gt;</content><category term="android"></category><category term="test"></category><category term="junit"></category></entry><entry><title>MobSF Android静态分析使用心得</title><link href="https://maxwell-nc.github.io/android/mobsfAnalys.html" rel="alternate"></link><published>2017-05-19T00:00:00+08:00</published><updated>2017-05-19T00:00:00+08:00</updated><author><name>Maxwell-nc</name></author><id>tag:maxwell-nc.github.io,2017-05-19:/android/mobsfAnalys.html</id><summary type="html">&lt;h2&gt;前序&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;此前也接触过一些第三方静态分析工具，因为工作原因接触了一款开源移动App安全框架&lt;a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF"&gt;MobileSecurityFramework&lt;/a&gt;，经过一番折腾后决定写下一篇博文记录一下心得。&lt;/p&gt;
&lt;h2&gt;搭建环境&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;本文是基于Windows搭建的Android App静态分析环境，首先是先要到&lt;a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF"&gt;Github&lt;/a&gt;上拿去拉一份源码下来。由于这个框架是基于Python开发的，而且需要反编译Apk，所以我们列下需要的环境清单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python 2.7(不能使3.x版本，低于2.7我也没有试过)&lt;/li&gt;
&lt;li&gt;Oracle JDK 1.7+&lt;/li&gt;
&lt;li&gt;MobSF源码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;以上是静态分析需要的环境，另外再官方的文档中写了一句推荐使用虚拟机环境搭建，否则存在安全问题，这里只是试用一下就不使用虚拟机了。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;拿到源码后解压到一个目录里，在这个目录打开CMD，输入命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;py -2 pip install -r requirements.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;注意我这里因为同时安装了Python2.x和3.x，所以使用py启动器来指定版本，如果只有Python2.x，可以直接采用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip install -r …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h2&gt;前序&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;此前也接触过一些第三方静态分析工具，因为工作原因接触了一款开源移动App安全框架&lt;a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF"&gt;MobileSecurityFramework&lt;/a&gt;，经过一番折腾后决定写下一篇博文记录一下心得。&lt;/p&gt;
&lt;h2&gt;搭建环境&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;本文是基于Windows搭建的Android App静态分析环境，首先是先要到&lt;a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF"&gt;Github&lt;/a&gt;上拿去拉一份源码下来。由于这个框架是基于Python开发的，而且需要反编译Apk，所以我们列下需要的环境清单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python 2.7(不能使3.x版本，低于2.7我也没有试过)&lt;/li&gt;
&lt;li&gt;Oracle JDK 1.7+&lt;/li&gt;
&lt;li&gt;MobSF源码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;以上是静态分析需要的环境，另外再官方的文档中写了一句推荐使用虚拟机环境搭建，否则存在安全问题，这里只是试用一下就不使用虚拟机了。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;拿到源码后解压到一个目录里，在这个目录打开CMD，输入命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;py -2 pip install -r requirements.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;注意我这里因为同时安装了Python2.x和3.x，所以使用py启动器来指定版本，如果只有Python2.x，可以直接采用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip install -r requirements.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;其中requirements.txt是运行MobSF的Python依赖环境。如果安装完成，接下来就是运行MobSF的服务器了，在命令行输入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python manage.py runserver
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;同样需要注意Python版本问题，第一次启动服务器会自动安装服务器需要的东西，主要是nuget、binskim、binscope等东西，国内的用户注意代理，否则可能卡住不动。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;note：&lt;/strong&gt;如果第一次安装失败不慎退出了，可以进入install目录先运行setup.py手动安装，然后在执行runserver命令。安装之后会自动生成一个自启动bat文件，根据源代码可以看出实际上他就是运行rpc_client.py。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;如果一切顺利的话，可以看到Django运行成功：
&lt;img alt="Django" src="../images/mobsfAnalys/1.jpg"&gt;
&amp;emsp;&amp;emsp;这个监听端口可以通过指定启动参数来修改，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python manage.py runserver 8100
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;然后可以打开浏览器输入地址，比如默认端口为：&lt;a href="http://127.0.0.1:8000/"&gt;http://127.0.0.1:8000/&lt;/a&gt;，我这边出现了一个这样的问题（也许你可以直接看到成功画面，恭喜）：
&lt;img alt="error" src="../images/mobsfAnalys/2.jpg"&gt;
&amp;emsp;&amp;emsp;如果和我一样出现“Don't Play Around. An Error just popped in!”的朋友，可以执行后重新启动服务器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python manage.py migrate 
python manage.py makemigrations
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;注意原因是“no such table: StaticAnalyzer_staticanalyzerandroid”才适用这个方法。成功之后就可以看到MobSF的界面：
&lt;img alt="server" src="../images/mobsfAnalys/3.jpg"&gt;
&amp;emsp;&amp;emsp;这样就算搭建完成了，当然也有可能上传App文件的时候发生错误，这就需要大家动动脑袋来处理了。&lt;/p&gt;
&lt;h2&gt;MobSF静态分析&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;使用MobSF的静态分析十分简单，直接上传一个Apk包，等待服务器解包反编译分析结果即可。不过我使用了多次发现这个框架很有可能卡在MalwareAnalyzer上面，可能是联网检查的问题，具体我并没有分析，然后假设你中断了操作，下次再启动会重新解包重新分析，十分耗时。一切正常的话，你将会看到分析报告页面：
&lt;img alt="Analys" src="../images/mobsfAnalys/4.jpg"&gt;
&amp;emsp;&amp;emsp;这个分析报告可以说“仅供参考”，比如说PERMISSION的检测，含有&lt;code&gt;android.permission.INTERNET&lt;/code&gt;就说Dangerous（后面会分析源码），这是比较令人费解的。毕竟这个权限只要是网络应用都会使用到，那岂不是所有的应用都是危险？？&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;而对于Code Analysis里面的ISSUE，其中一个“App can read/write to External Storage. Any App can read data written to External Storage.”也是SEVERITY为High，其实也只是提示你其他App可能会串改数据而已，而不是说你不能使用外部存储器，所以只要你访问了外部存储器的API就一定会报这个问题（汗颜）。&lt;/p&gt;
&lt;h2&gt;源码及原理分析&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;由于上面给出的分析结果有点让人摸不着头脑，而且也没有标注错误的位置，所以只能从源码入手，分析其原理。源码的目录结构十分清晰，由于我们采用的事静态分析，可以直接找到&lt;code&gt;StaticAnalyzer&lt;/code&gt;目录。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;├─migrations
├─test_files
├─tools
│  ├─apkid
│  │  └─rules
│  ├─d2j2
│  │  └─lib
│  ├─enjarify
│  │  ├─enjarify
│  │  │  ├─jvm
│  │  │  │  ├─constants
│  │  │  │  └─optimizatio
│  │  │  └─typeinference
│  │  └─tests
│  └─mac
└─views
    ├─android
    └─ios
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;通过打印StaticAnalyzer目录的树结构可以粗略知道，migrations是迁移文件，test_files是用来测试静态测试的文件，tools是用来反编译等的工具，views才是我们想要找的分析源码。
&amp;emsp;&amp;emsp;直接到StaticAnalyzer\views\android目录下可以很快找到对应分析的源码（十分清晰的模块名）。比如我们找一下上文所述的Premission问题，一眼可以看到dvm_permissions.py,打开发现只是一个字典，对应每个权限和状态值、描述等信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;INTERNET&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;dangerous&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;full Internet access&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Allows an application to create network sockets.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;这还不能说明什么，我们可以继续发现manifest_analysis.py文件中导入了dvm_permissions，其中代码中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;permissions&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mfxml&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getElementsByTagName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;uses-permission&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;permission&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;permissions&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;perm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;permission&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getAttribute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;android:name&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;perm&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;prm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;
    &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rfind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;prm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:]&lt;/span&gt;
    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;dvm_perm&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DVM_PERMISSIONS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;MANIFEST_PERMISSION&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;prm&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;KeyError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;dvm_perm&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
            &lt;span class="s2"&gt;&amp;quot;dangerous&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="s2"&gt;&amp;quot;Unknown permission from android reference&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="s2"&gt;&amp;quot;Unknown permission from android reference&amp;quot;&lt;/span&gt;
        &lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;看以看出这个权限的检测直接就是根据dvm_permissions.py中定义的字典来决定的，并没有更多的判断规则。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;接下来我们看看Code Analysis ISSUE：“The App uses an insecure Random Number Generator.”的判断原理。同理我们也可以找到code_analysis.py文件直接分析。先找到一个字典字段描述这个问题：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;rand&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;The App uses an insecure Random Number Generator.&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后我们搜索key'rand'可以看到,&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;typ&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;apk&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;java_src&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;app_dir&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;java_source/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;typ&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;studio&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;java_src&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;app_dir&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;app/src/main/java/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;typ&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;eclipse&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;java_src&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;app_dir&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;src/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="n"&gt;dat&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;file_pointer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;findall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;r&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;java\.util\.Random&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dat&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;rand&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;jfile_path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;java_src&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;emsp;&amp;emsp;表示只要使用了&lt;code&gt;java.util.Random&lt;/code&gt;这个类就会报这个问题。实际上即使是&lt;code&gt;java.security.SecureRandom&lt;/code&gt;也存在安全风险。所以这类问题还是比较难处理的，不过如果不涉及安全的随机数（比如为用户起一个随机昵称，而这个昵称并不作为唯一标识），即使使用了也没有关系，这里就不展开讨论了。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;其他还有很多检查大体原理相似，如果经常需要用到某一个检测，也可以把那部分源码单独拷出来做成一个单独检测工具，这样不需要每次都去完整的检测才知道结果。&lt;/p&gt;
&lt;h2&gt;尾声&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;使用过后我觉得很失望，很多功能都没有，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不支持排除第三方&lt;/li&gt;
&lt;li&gt;不支持显示错误行数或者位置&lt;/li&gt;
&lt;li&gt;不支持Mapping&lt;/li&gt;
&lt;li&gt;不支持自定义规则&lt;/li&gt;
&lt;li&gt;不支持标记已处理的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;很多情况下使用这个框架，都是由程序员搭建好一个服务器供开发人员或者是非开发人员去检测使用。倘若出了这么一份充满Dangerous和High SEVERITY的报告给非技术人员看，更重要的是无论你怎么改都无法去掉，这想必得花好一段时间去解析吧？所以个人不是很推荐这个框架给非技术人员使用。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;当然目前这个框架还处于Beta阶段，版本号也没有到1.0，我仅仅使用了它的静态分析功能，它还有动态分析等等，总体来说这是一个很不错的工具，但是还没有足够的完善，我们期待他更好地发展。特别是规则自定义，希望可以单独出来，这样可以让更多开源力量去维护增强它。&lt;/p&gt;</content><category term="android"></category><category term="python"></category><category term="automation"></category><category term="analys"></category></entry></feed>